## Доступ до MQTT-брокера

Для доступу до брокера система повинна отримати два сертифікати та ключ.
Кожна система має свій унікальний ідентифікатор (**sys_id**).
Приклади ідентифікаторів (систем для тестування):

- MQAaAJrAWAThGQAA - Саша
- MQAaAJrAWASgJwAA - Денис

Серійні ідентифікатори будуть трохі більшої довжини, буде додана випадкова сіль для забезпечення більшого захисту.

Для отримання сертифікатів та ключа, треба використовувати CA Cert, який можна завантажити з 

```
GET http://5.187.3.28/certs/ca.crt
```

ПО сервера генерує набір файлів по ідентифікатору системи. Вся подальша робота з системою відбувається по цьому ідентифікатору. Бажано шоб значення ідентифікатора було в самому клієнтському
сертифікаті, наприклад в **Common Name**.
Завантаження файлів робиться на етапі виробництва.
При першому вмиканні, система завантажує три файли сервера:

```
GET https://5.187.3.28:8448/?sys_id=$sys_id&type=cacert&role=system
GET https://5.187.3.28:8448/?sys_id=$sys_id&type=clientcert&role=system
GET https://5.187.3.28:8448/?sys_id=$sys_id&type=clientkey&role=system
```

Це дає доступ до MQTT-брокера. Доступи до відповідних топіків вже налаштовуються
на боці брокера.
Для загальних комад до системи, можна виділити топік:

**server/{sys_id}/command**

Доступ на підписку до цього топіка повинен бути дозволений виключно для зʼєднань з **CN=sys_id**. Доступ для публікаціі в цей топік повинен бути обмежен внутрішнім сервісам сервера Фенікса.

Для публічної інформації про систему, система публікує в топік

**system/{sys_id}/info**

Доступ на публікації до цього топіка повинен бути дозволений виключно для зʼєднань з **CN=sys_id**. Доступ для підписки на цей топік повинен бути обмежен внутрішнім сервісам сервера Фенікса, та всіма додатками.


## Перше додавання системи.

Дана процедура робиться користувачем або встановником. Ця процедура спрацює тільки якшо немає ще користувачів в системі.

Перше шо треба, це дати команду системі, на додавання нового користувача.
Це можна зробити декількома способами:
1. Знаючи номер телефона системи, відправити на систему SMS зі словом **link**.
   Система відправить у відповідь тимчасовий код для додавання.
2. Маючи ідентифікатор системи **sys_id** (як варіант, qr-код може бути в коробці сигналізації), відправити команду **link** в топік **server/{sys_id}/command**.

Система дає запит до сервера Фенікса на створення нової пари **система<->користувач**.

```
GET https://5.187.3.28:8448/create_link.php?sys_id=$sys_id&public_key=$public_key
```

Де:
- sys_id - $sys_id
- public_key - Відкритий ключ шифрування RSA-2048 для отримання AES-256 ключа в подальшому. base64 encoded.

Сервер створює тимчасову сессію, тривалістю 5 хвилин.
Повертає тимчасовий код:

```json
{
    "status":"success",
    "link_code": "543217",
    "expires_in": $unixtime
}
```

**Увага!** Сервер повинен гарантувати шо не буде сгенеровано одночасно два однакових кода.

Якшо процедура робиться через SMS, система відправить **link_code** відправнику SMS"link" або на номер адміністратора. Якшо команда "link" була отримана через MQTT-брокер, то код буде відправлено на номер адміністратора, або у топік **system/{sys_id}/info**.

Користувач, якшо отримав SMS з кодом, вводить його в додатку.

Додаток робить свій запит на створення пари спілкування:

```
GET https://5.187.3.28:8448/create_link.php?app_id=$app_id&link_code=218353
```

Якшо є активна сессія зʼєднання, сервер:

- генерує ідентифікатор **$link_id** для пари спілкування.
- генерує необхідні SSL-файли для додатку.
- додає до прав публікації для системи **CN=sys_id** в топіки: __alarm/$link_id/*__
- додає до прав підпіски для системи **CN=sys_id** на топіки: __application/$link_id/*__
- аналогічно підготовлює права для додатку, для його **CN=link_id**.
- зберігає публічний RSA-2048 ключ для відправлення даних системі.
- Відправляє системі в топік **server/$sys_id/command** дані про нову пару:

```
new_link 543217 **$link_id**
```

Що треба повернути у відповіді запиту до сервера:

```json
{
    "status":"success",
    "sys_id":"aaa_test1",
    "public_key":"AAAABBB",
    "ssl_cacert":"-----BEGIN CERTIFICATE-----\nMIID ... 4qmZU=\n-----END CERTIFICATE-----\n",
    "ssl_clientcert":"-----BEGIN CERTIFICATE-----\nMIIC8T ... aMEs6A==\n-----END CERTIFICATE-----\n",
    "ssl_clientkey":"-----BEGIN PRIVATE KEY-----\nMIIEv ... Tstg==\n-----END PRIVATE KEY-----\n",
    "message":"Link created successfully",     
    "link_id":"$link_id"
}
```

(До Ярослава) SSL-файли може якось по іншому ти зробиш, дивись сам.

Додаток генерує AES-256 ключ наскрізного щифрування та шифрує його RSA-2048 ключем **public_key**. Та відправляє його на сервер запитом:

```
GET https://5.187.3.28:8448/send_aes_key?link_id=$link_id&aes_key=kkkkkkk
```

Сервер повинен зберегти ключ десь у себе в базі, на випадок якшо сигналізації
знадобиться його завантажити повторно.
Сервер перенаправить ключ системі у топік **server/$sys_id/command**:

```
aes_key $link_id:kkkkkkk
```

Сигналізація розшифрує своїм закритим RSA-2048 ключем, та збереже в себе и
в подальшому буде його використовувати для даних у топіках:

- alarm/$link_id/state
- alarm/$link_id/events
- alarm/$link_id/status (?)
- alarm/$link_id/settings
- alarm/$link_id/info
- application/$link_id/command
- application/$link_id/settings/request
- application/$link_id/system
- application/$link_id/settings/sounds

Якшо процедура робиться способом №2, через додаток, скануванням QR-коду, код підтвердження вводити не треба.
Додаток, підписується на топік **system/{sys_id}/info**.
Відправляє команду **link** в топік **server/{sys_id}/command**.
Якшо система свіжа, і ше немає телефона адміністратора, система відправить у топік
**system/{sys_id}/info** код на створення зʼєднання:

```json
{
    ...
    "link_code": "543217",
    ...
}
```

Додаток, отримавши цей код, далі діє аналогічно попередній процедурі.

Якшо в системі вже задан номер адміністратора, система відправить у топік
**system/{sys_id}/info**:

```json
{
    ...
    "link_code": "@sms",
    ...
}
```

Додаток повинен надати можливість введення кода. І далі по процедурі аналогічно.


### Поділитись автомобілем.

Процедура надавання доступа до автомобіля іншому користувачу в цілому аналогічна описаній.

Додаток№1 - додаток користувача шо вже має доступ до авто.
Додаток№2 - додакток, якому треба надати доступ.

Додаток№1 відправляє запит на створення пари спілкування на систему через існуючий топік керування системою **application/$link_id/command**:

```
share $timestamp
```

Система робить свій запит на сервер початку сессії створення пари, код для створення пари відправляє у топік **alarm/$link_id/events**:

```
share:$link_code
```

Додаток№1 відображає на єкрані QR-код на створення пари, сгенерований із кода **link_code**. Під QR-кодом треба показати сам код, на випадок якшо не має можливості просканувати код на зʼєднання, наприклад коли треба поділитись автомобілем на відстані.

Додаток№2 сканує цей код (або код вводиться вручну), і далі йде по стандартній процедурі створення пари, починаючи зі свого запиту до сервера на створення пари.

По завершенню процедури додавання, додаток ініціатор побачить в топіку **alarm/$link_id/info** в полі **users** новий запис, і може налаштувати права доступа через топік **application/$link_idN/command**, наприклад установити обмеження по часу:

```
edit_info:users:$link_idN:expires_in:$unixtime
```

### Керування користувачем

В системі для користувачів є набір опцій.
Наприклад для користувача можуть бути призначені обмеження.
Також доступ для користувача може надаватись на обмежений час.
Доступ може бути обмежений визначеною позицією і автоматично скасовуюється якшо система переміщена.

Система передає список користувачів, у яких є доступ в persistent топік **alarm/$link_id/info**.

```json
{
    ....
    "users": [
        {
            "sys_id": "$sys_id1",
            "link_id": "$link_id1",
            "name": "Головний користувач",
            "admin": true,
            "can_control_over_SMS": true,
            "can_control_users": true,
            "expires_in": 121313213213,
            "position_limit": false,
            "position_lat": 22.22222,
            "position_lon": 33.33333
        },
        {
            "sys_id": "$sys_id2",
            "link_id": "$link_id2",
            "name": "Інший якийсь користувач",
            "admin": false,
            "can_control_over_SMS": false,
            "can_control_users": false,
            "expires_in": 121313213213,
            "position_limit": false,
            "position_lat": 22.22222,
            "position_lon": 33.33333
        },
        ...
    ],
    ...
}
```

Додаток, зчитуючи запис з свого топіка **alarm/$link_id/info**, з масиву **users**, може бачити всіх користувачів, які теж мають доступ до системи. В тому числі бачить запис про себе, в якому є імʼя користувача, перелік прав та обмежень.

Поле users[].admin віртуальне. Воно показуює те, шо даний користувач є головним (першим) для системи. Його неможливо змінити. У нього атрібут **can_control_users** завжди **true**. (Дивись розділ про видалення).

Якшо для наявного користувача немає прав на керування іншими користувачами, то запис **users** буде містити тільки одну запис, саме про себе.

Якшо є права на керування іншими користувачами, то додаток може відправляти команду у свій **application/$link_id/command** команду на керування правами доступа для іншого користувача **link_idN**:

```
edit_info:users:$link_idN:can_control_over_SMS:false
```

Якшо це команда

```
edit_info:users:$link_idN:position_limit:true
```

то система визначить своє місцеположення, та встановить поля **position_lat** та **position_lon**. При зміні положення, система сама скасує доступ.


При зміні прав, система оновить записи для всіх своїх користувачів

**alarm/$link_id1/info**, **alarm/$link_id2/info**,...

### Видалення користувача

Користувач може бути видалений:

1. З додатку. Якшо у користувача є право на керування іншими користувачами.
2. Системою. Якшо був наданий доступ на час, або на визначеноє місцеположення.

В будь якому випадку, процедуру видалення робить система.

#### 1. Видалення через додаток.

Додаток посилає команду на видалення користувача **link_idN** в свій! топік керування **application/$link_id/command**.

```
user_remove:$link_idN
```

Далі система, якшо у користувача **$link_id** є відповідні права, ініціює процедуру видалення.

Один користувач може видали іншого користувача тільки якшо в нього є права "керування користувачами" (can_control_users=true).
Виняток - це видаляння самого себе. Додаток **$link_id** може відправити у топік
**application/$link_id/command**

```
user_remove:$link_id
```

У випадку, якшо це перший користувач (адмін), то перший зі списку користувач з правами "керування користувачами" стає адміном. Якшо такого немає, то перший зі списку стає адміном і йому автоматично вмикається право "керування користувачами".
Якшо інших користувачів не було, система стає "чистою" і процедуру додавання можна ініцюювати по процедурі **Перше додавання системи.**

#### 2. Видалення по події вичерпаня часу доступу або по зміні місцеположення.

Якшо система самостійно приймає рішення про скасування доступу, то вона сама починає процедуру видалення.

### Процедура видалення.

Система відправляє у persistent топік додатку **link_idD** повідомлення, по якому додаток може зрозуміти шо було скасовано доступ.

**alarm/$link_idD/state**

чи (та?)

**alarm/$link_idD/info** (?)

```json
{
    "removed": true,
    "message": "Доступ до системи припинено. Вичерпан час."
}
```

Для всіх інших користувачів, оновлюється значення топіка **alarm/$link_idN/info**, поле **users**.

Далі, система, відправляє на сервер команду на видаллення пари керування.

```
GET https://5.187.3.28:8448/remove_link.php?link_id=$link_id
```

Це за для того, шоб сервер міг налаштувати ACLs, видалити public_key, та іншу інформацію про систему, додаток та звʼязку $link_id, якшо це потрібно.

Цей єтап не є обовʼязковим, бо система в будь якому випадку видаляє дані пари спілкування, відписується від топіків додатку користувача.


## Топік alarm/$link_id/info

Додан ретейнед топік **alarm/$link_id/info**.
Він містить всіляку статичну (відносно до стану) інформацію про систему.

- Імʼя автомобіля
- Баланси SIM-карт
- Список користувачів, яким надано доступ

```json
{
    "name": "Моя машина",
    "sim1": {
        "balance": 55,
        "name": "SIM1",
        "phone": "+12223213123"
    },
    "sim2": {
        "balance": 55,
        "name": "SIM2",
        "phone": "+12223213123"
    },
    "users": [
        {
            "sys_id": "$sys_id2",
            "link_id": "$link_id2",
            "name": "Інший якийсь користувач",
            "admin": false,
            "can_control_over_SMS": false,
            "can_control_users": false,
            "expires_in": 121313213213,
            "position_limit": false,
            "position_lat": 22.22222,
            "position_lon": 33.33333
        }
    ],
}
```

Додаток може встановлювати деякі значення.

#### Керування правами користувачів (якшо є відповідні права)

```
edit_info:users:$link_idN:can_control_over_SMS:false
```

Для цієї команди треба мати права "керування користувачами".
Додаток може мати можливість переписувати поле "users[].name"
для зручності. Але значення в системі може міняти тільки користувач
з правами "керування користувачами".

#### Встановлення імені авто.

```
edit_info:name:Моя прьєльєсть!
edit_info:sim1.name:Київстар
```

Додаток може мати механізм зміни імені всередині своєї копії додатку.
Глобально міняти імʼя системи, може тільки перший користувач.


## Тестування


```

curl -v --cacert ./keys_ca_cert.crt "https://5.187.3.28:8448/?sys_id=aaa_test1&type=cacert&role=system"
curl -v --cacert ./keys_ca_cert.crt "https://5.187.3.28:8448/?sys_id=aaa_test1&type=clientcert&role=system"
curl -v --cacert ./keys_ca_cert.crt "https://5.187.3.28:8448/?sys_id=aaa_test1&type=clientkey&role=system"



curl -v --cacert ./keys_ca_cert.crt "https://5.187.3.28:8448/create_link.php?sys_id=aaa_test1&public_key=AAAABBB"
```

```json
{"status":"success","link_code":"352658","expires_in":300}
```

```
curl -v --cacert ./keys_ca_cert.crt "https://5.187.3.28:8448/create_link.php?app_id=app_id1&link_code=352658"
```

```json
{
    "status":"success",
    "sys_id":"aaa_test1",
    "public_key":"AAAABBB",
    "ssl_cacert":"-----BEGIN CERTIFICATE-----\nMII ... U=\n-----END CERTIFICATE-----\n",
    "ssl_clientcert":"-----BEGIN CERTIFICATE-----\nMI ... 6A==\n-----END CERTIFICATE-----\n",
    "ssl_clientkey":"-----BEGIN PRIVATE KEY-----\nMII ... tg==\n-----END PRIVATE KEY-----\n",
    "message":"Link created successfully",
    "link_id":"app_id1"
}
```

### Є шо обсудити

1. Хто і коли генерує link_id? В мене є пункт "сервер... - генерує ідентифікатор **$link_id** для пари спілкування.".

2. Заминити поле expires_in значення 300 на таймстамп реального значення unixtime, коли буде завершено очікування.

3. Прибрати сертифікат для доступу до сервера **https://5.187.3.28:8448** з вільного доступу. Шоб не було доступу всім бажаючим до API. Будемо його прошивати на виробництві. Можливо треба три файли? Бо я можу вільно завантажити через curl --insecure ...


